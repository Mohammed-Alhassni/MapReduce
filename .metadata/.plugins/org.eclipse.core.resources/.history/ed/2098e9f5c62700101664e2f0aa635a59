import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class MapReduce {
    public static void main(String[] args) throws InterruptedException, IOException, ExecutionException {
        String samplePath = "/Users/mohmmedmsoud/Desktop/sem2 temp/pds project/SAMPLE3.txt";
        long startNs = System.nanoTime();

        // Extract blocks in parallel
        ExecutorService executor = Executors.newFixedThreadPool(4);  // 4 threads for block extraction
        List<Callable<List<ArrayList<String>>>> tasks = new ArrayList<>();
        tasks.add(() -> BlocksExtractor.extractBlocks(samplePath));

        List<Future<List<ArrayList<String>>>> futures = executor.invokeAll(tasks);
        List<ArrayList<String>> blocks = futures.get(0).get();  // Get the result of block extraction

     // In your Map and Reduce tasks
        List<Callable<Void>> mapTasks = new ArrayList<>();
        for (ArrayList<String> block : blocks) {
            mapTasks.add(() -> {
                try {
                    Mapper.map(block);  // Process each block with MapFun
                } catch (Exception e) {
                    e.printStackTrace(); // Print any exception to the console
                }
                return null;
            });
        }
        executor.invokeAll(mapTasks);  // Execute mapping in parallel

        List<Callable<Void>> reduceTasks = new ArrayList<>();
        for (ArrayList<String> block : blocks) {
            reduceTasks.add(() -> {
                try {
                    Map<String, Object> classAndFeatures = Mapper.map(block);  // Get the mapped features
                    Reducer.reduce(classAndFeatures);  // Write to CSV
                } catch (Exception e) {
                    e.printStackTrace(); // Print any exception to the console
                }
                return null;
            });
        }
        executor.invokeAll(reduceTasks);  // Execute reducing in parallel


        executor.shutdown();  // Shut down the executor

        long durationMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
        System.out.println("Done, took " + durationMs + "ms");
    }
}
