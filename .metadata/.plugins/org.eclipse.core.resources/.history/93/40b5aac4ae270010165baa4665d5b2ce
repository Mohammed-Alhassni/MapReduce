import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;




public class SampleTester {
	public static void main(String[] args) throws InterruptedException, IOException {
		String samplePath= "SAMPLE3.txt";
	    BufferedReader reader = new BufferedReader(new FileReader(samplePath));
	    

	    String line;
	    ArrayList<String> TempData= new  ArrayList<>();
	    Boolean isForDistrubtion= false;

	    while ((line = reader.readLine()) !=  null) {
	    	if (!line.replace(" ", "").equals("")) {
	    		

	    		
	    		if (line.contains("class ") && !(TempData.isEmpty())) {
	    			 BufferedReader distrubutionReader = new BufferedReader(new FileReader(samplePath));
	    			 String dirtrubtionLine;
	    			 while ((dirtrubtionLine = distrubutionReader.readLine()) !=  null) {
	    				 	    				 
	    			    	if (!dirtrubtionLine.replace(" ", "").equals("") && dirtrubtionLine.contains("Distribution:")) {	    			    		
	    			    		isForDistrubtion= true;	    			    				
	    			    	}
	    			    	
	    			    	if (isForDistrubtion && dirtrubtionLine.contains(TempData.get(0))) {
    			    			TempData.add(dirtrubtionLine);
    			    			//System.out.println(TempData + "\n");
    			    			MapperFun(TempData);
    			    			TempData= new  ArrayList<>();
    			    			isForDistrubtion= false;
    			    			break;
    			    		}
	    			    	
	    			 } 
	    			 distrubutionReader.close();
	    			 
	    			 if (!line.matches("^class \\d+\\.\\d+: \\w+ \\d+ \\(\\d+\\.\\d+%\\)$")) {
	    				 TempData.add(line);	
	    			 }
	    			 
	    			 
	    					
	    		} else if ((line.matches("^class \\d+\\.\\d+: \\w+$")) && (TempData.isEmpty())) {
	    			TempData.add(line);
	    		} else if (!TempData.isEmpty()) {
	    			TempData.add(line);
	    		}   		
	    	}
	    }  
	    
	    
	    reader.close();
	    
	    
	    
        long startNs = System.nanoTime();


        long durationMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);

        System.out.println("Done, tooks" + durationMs + "ms");
                    
	}


	
	public static Map<String, Object> MapperFun(ArrayList<String> Data) throws FileNotFoundException, IOException {
		Map<String, Object> classAndFeatures= new HashMap<>();
		Map<String, String> featuresMap= new HashMap<>();
		
		ArrayList<String> words = new ArrayList<>();
		
        for (int i=0; i<Data.size(); i++ ) { 
        	String[] split = Data.get(i).split(" |\\.0");
        	for (int n=0; n<split.length; n++ ) {
        		
            	words.add(split[n]);
    	 }
	    }
        
        System.out.println(words);
        
        int iterationIndex=0;
        
        for (String feature: words) {
        	if (feature.replace(" ", "").equals("=")) {
        		featuresMap.put(words.get(iterationIndex-1), words.get(iterationIndex+1));
        	}
        	iterationIndex++;
        }
        
        featuresMap.put("Samples", words.get(words.size()-2));
        featuresMap.put("Percentage", words.get(words.size()-1).replace(")", "").replace("(", ""));
        
        
        classAndFeatures.put(words.get(3), featuresMap);
        

        ReducerFun(classAndFeatures);

      System.out.println(featuresMap);
      System.out.println(classAndFeatures + "\n");
        
        
        return  classAndFeatures;

	}
	
	public static void ReducerFun(Map<String, Object> classAndFeatures) throws FileNotFoundException, IOException  {
		String samplePath = "output.csv";
		String className = null;
		File file = new File(samplePath);
		
		//set to extract the class name of the Map (classAndFeature Map)
		Set<String> classNameSet = new HashSet<>();
		classNameSet= classAndFeatures.keySet();
		
		for (String setELement: classNameSet) {
			//here we only have one key and object holding the feature, we want that key 
			//iterate through the map keys, although there only one key
			className= setELement;
			
		}
		
		
		if (!file.exists()) {
			try (FileWriter writer = new FileWriter(samplePath)) {
				System.out.println("New 'Output.csv' have been created");

				Map<String, String> featuresMap= new HashMap<>();
				Object interMediate= classAndFeatures.get(className);
				featuresMap= (Map<String, String>) interMediate;
				ArrayList<String> featureMapKeys= new  ArrayList<>();
				
				// Write header
				writer.append("class");
				for (String key : featuresMap.keySet()) {
					writer.append(","+ key);
				}
				
				writer.append("\n");
				
				
				// Write first row
				for (String key : featuresMap.keySet()) {
					featureMapKeys.add(key);
				}
				
				writer.append(className);
				for (String key : featureMapKeys) {
					writer.append(","+ featuresMap.get(key));
				}
				writer.append("\n");
				
				System.out.println("Head and Row added");
			}
    		
		} else if (file.exists()) {
				try (FileWriter writer = new FileWriter(samplePath, true)) {
				
				
				Map<String, String> featuresMap= new HashMap<>();
				
				Object interMediate= classAndFeatures.get(className);
				
				featuresMap= (Map<String, String>) interMediate;
				
				ArrayList<String> featureMapKeys= new  ArrayList<>();
				
				// Write other rows
				for (String key : featuresMap.keySet()) {
					featureMapKeys.add(key);
				}
				
				writer.append(className);
				for (String key : featureMapKeys) {
					writer.append(","+ featuresMap.get(key));
				}
				writer.append("\n");
				
				System.out.println("Row added");
				
			}
		}
           
	}

}
